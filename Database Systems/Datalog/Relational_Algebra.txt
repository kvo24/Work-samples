### Warm-up with Relational Algebra


1. Write the equivalent SQL query to this relational algebra plan: figs/ra.pdf.


/*** ANSWER ***/

with living_grandparents as (
    select *
    from person_living p, parent_child c, (select p1 as p3, p2 as p4 
                                           from parent_child) d
    where p.x = c.p1 and c.p2 = d.p3
)
select p1, max(y) as z
from (select p1, p3, count(*) as y
      from living_grandparents
      group by p1, p3)
group by p1


/*** EXPLANATION ***/

GREEK SYMBOLS
Gamma: group-by
Theta: join
Rho: rename
Pi: project
Sigma: select

TABLES
person_living(x): lists living persons
parent_child(p1, p2): lists parent-child pairs

OPERATIONS
1. join person_living and parent_child on x = p1:
    finds parent_child tuples whose parent is living
2. rename parent_child attributes p3, p4
3. join (1) and (2) on p2 = p3:
    finds children from (1) who themselves have children
    living grandparents
4. group by p1, p3, count(*):
    for every unique living grandparent-parent combo, 
    count the number of grandchildren (= y)
5. group by p1, max(y):
    for each living grandparent, calculate the child (parent)
    who gave them the most number of grandchildren, and
    report that max number (= z)
=> We find, for every living grandparent, a number that represents
   the maximum number of grandchildren provided to them by any single
   child of theirs.



2. Write a relational algebra plan for the following SQL query:


    ```sql
    select a.p
    from   person_living a, male b
    where  a.p = b.name and 
           not exists (select * 
                       from   parent_child c, female d 
                       where  c.p1=d.name and c.p2=a.p)
   ```


/*** ANSWER ***/

T1(p1, p2, name) = parent_child(p1, p2) Join[p1 = name] female(name)
T2(p, name) = person_living(p) Join[p = name] male(name)
T3(p) = Project[p] T2(p, name)
T4(p, p1, p2, name) = T3(p) Join[p = p2] T1(p1, p2, name)
T5(p) = Project[p] T4(p, p1, p2, name)
T6(p) = T3(p) SetDifference[] T5(p)
